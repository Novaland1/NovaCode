// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol";
import "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol";

    interface ITokenBXV {

    function operatorSend(address sender, address recipient, uint256 amount, bytes calldata data, bytes calldata operatorData) external;
    function send(address recipient, uint256 amount, bytes calldata data) external;
    function balanceOf(address account) external view returns (uint256); 
    
    function granularity() external view returns (uint256);
    function defaultOperators() external view returns (address[] memory);
    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);
    function authorizeOperator(address operator) external;
    function revokeOperator(address operator) external;
    }

   interface ICryptoLandCitizenNFT412 {
    function updateValor(uint256 tokenId, int256 valorChange) external;
    function updateCredit(uint256 tokenId, int256 creditChange) external;
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
   }

   interface ICryptoIrrevocableNoteNFT {
    function mint(address to, uint256 amount, uint256 maturityDate) external returns (uint256);
    function burn(uint256 tokenId) external;
    function ownerOf(uint256 noteId) external view returns (address);
    function totalSupply() external view returns (uint256);  
    function balanceOf(address owner) external view returns (uint256);
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
    }

    contract NovaIrrevocableNote is IERC777Recipient, IERC777Sender, Ownable {
    IERC1820Registry private constant ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    
    bytes32 private constant TOKENS_RECIPIENT_INTERFACE_HASH = keccak256("ERC777TokensRecipient");
    bytes32 private constant TOKENS_SENDER_INTERFACE_HASH = keccak256("ERC777TokensSender");

    ICryptoIrrevocableNoteNFT public nftContract;
    ITokenBXV public tokenB;
    ICryptoLandCitizenNFT412 public citizenNFT;
   
    struct NoteInfo {
    address issuer;
    uint256 amount;
    uint256 startTime;
    uint256 maturityDate;
    uint256 delayCount;
    uint256 delayFees;
    bool isOpenForAll;
    bool isWithdrawn;
    bool isFrozen;        
    bool issuerUnfrozen;  
    }
  
    mapping(uint256 => NoteInfo) public notes;  
    mapping(address => uint256) public userBalance; 
   
    event NoteFrozen(uint256 indexed tokenId, uint256 timestamp);
    event IssuerUnfrozeNote(uint256 indexed tokenId, uint256 timestamp);
    event NoteUnfrozen(uint256 indexed tokenId, uint256 timestamp);
    
    uint256 public constant REQUEST_FEE = 0.0001 ether; // 0.0001 ether
    uint256 public constant CANCEL_FEE = 0.0003 ether;  // 0.0003 ether
    uint256 public constant DELAY_FEE = 0.0005 ether;   // 0.0005 ether
    uint256 public constant ISSUER_UNFREEZE_FEE = 0.001 ether;   
    uint256 public constant HOLDER_UNFREEZE_FEE = 0.002 ether;  
    uint256 public constant MIN_NOTE_AMOUNT = 10*1e18;
    
    uint256 public constant MAX_DELAY_TIMES = 3;  
    uint256 public constant MAX_FEE_RATE = 5;  
   
    uint256 public totalDeposited;    
    uint256 public totalLocked;       

    address public feeReceiver;
    
    event FeeReceiverUpdated(address indexed oldReceiver, address indexed newReceiver);
   
    event WithdrawalRequested(uint256 indexed tokenId, address requester);
    event NoteDelayed(
        uint256 indexed tokenId, 
        uint256 startTime,
        uint256 newMaturityDate
    );
  
    event NoteWithdrawn(uint256 indexed tokenId, address withdrawer, uint256 amount);
   
    event NFTContractUpdated(address indexed oldContract, address indexed newContract);
   
    event BalanceWithdrawn(address indexed user, uint256 amount);

    event EtherReceived(address indexed sender, uint256 amount, uint256 expectedAmount);
   
    // Add a new event for interface registration
    event InterfaceRegistered(address indexed implementation, bytes32 indexed interfaceHash, string interfaceName);
    // Add new event for debugging token receive attempts
    event TokenReceiveAttempt(address indexed sender, address indexed from, address indexed to, uint256 amount);

   
    constructor(
    address _nftContract, 
    address _tokenB,
    address _citizenNFT,   
    address _feeReceiver,
    address initialOwner
   ) Ownable(initialOwner) {
    require(_nftContract != address(0), "Zero address not allowed");
    require(_tokenB != address(0), "Zero address not allowed");
    require(_citizenNFT != address(0), "Zero address not allowed");
    require(_feeReceiver != address(0), "Zero fee receiver");
    require(initialOwner != address(0), "Zero owner address");
    
    nftContract = ICryptoIrrevocableNoteNFT(_nftContract);
    tokenB = ITokenBXV(_tokenB);
    citizenNFT = ICryptoLandCitizenNFT412(_citizenNFT);
    feeReceiver = _feeReceiver;
    
    // Register interfaces with events for debugging
    bytes32 recipientHash = TOKENS_RECIPIENT_INTERFACE_HASH;
    bytes32 senderHash = TOKENS_SENDER_INTERFACE_HASH;
    
    ERC1820_REGISTRY.setInterfaceImplementer(
        address(this),
        recipientHash,
        address(this)
    );
    
    ERC1820_REGISTRY.setInterfaceImplementer(
        address(this),
        senderHash,
        address(this)
    );
    
    emit InterfaceRegistered(address(this), recipientHash, "ERC777TokensRecipient");
    emit InterfaceRegistered(address(this), senderHash, "ERC777TokensSender");
    }

    event TokenTransferDetails(
    address indexed operator,
    address indexed from,
    address indexed to,
    uint256 amount,
    bytes userData,
    bytes operatorData
    );

    event TokensReceived(address indexed from, uint256 amount);
    event NoteCreated(
    uint256 indexed tokenId, 
    address indexed issuer, 
    uint256 amount, 
    uint256 startTime,    
    uint256 maturityDate  
    );

   function getLastNonZeroDigit(uint256 amount) internal pure returns (uint256) {
    while (amount > 0 && amount % 10 == 0) {
        amount = amount / 10;
    }
    return amount % 10;
   }

    function tokensReceived(
    address /*operator*/,    
    address from,        
    address /*to*/,          
    uint256 amount,      
    bytes calldata /*userData*/,
    bytes calldata /*operatorData*/
    ) external override {
    
    emit StepExecuted("Start", amount);
    require(tokenB.balanceOf(from) > 0, "Must hold TokenB");
    emit StepExecuted("Balance Check Passed", tokenB.balanceOf(from));
    
    require(amount >= MIN_NOTE_AMOUNT, "Amount too small");
    emit StepExecuted("Amount Check Passed", amount);
   // Take the last digit and verify
    uint256 lastDigit = getLastNonZeroDigit(amount);
    require(lastDigit > 0 && lastDigit <= 9, "Last digit must be 1-9");
    emit StepExecuted("Last Digit Validated", lastDigit);    
   // Get the lock period and calculate the expiration time
    uint256 duration = getDuration(lastDigit);
    uint256 maturityDate = block.timestamp + duration;
    emit CalculationResult(lastDigit, duration, maturityDate);
    
    
   // Try to mint NFT
    uint256 nftId = nftContract.mint(from, amount, maturityDate);
   // Verify that the NFT was indeed minted successfully - key checkpoint
    require(nftContract.ownerOf(nftId) == from, "Note creation failed");

      if(address(citizenNFT) != address(0)) {
        uint256 issuerBalance = citizenNFT.balanceOf(from);
        if(issuerBalance > 0) {
            uint256 issuerTokenId = citizenNFT.tokenOfOwnerByIndex(from, issuerBalance - 1);
           // You can record this tokenId for subsequent operations or verification
            emit CitizenNFTUpdate("Found issuer citizenNFT", issuerTokenId);
        }
    }


     function setTokenBXVAddress(address newAddress) external onlyOwner {
        require(newAddress != address(0), "Invalid address");
        tokenB = ITokenBXV(newAddress);
        
    }

   
  
    
}


