// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC777/IERC777.sol";
import "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol";
import "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol";
import "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"
import "./CryptoLandCitizenNFT4124.sol";
import "./TokenAs2.sol";

contract CryptoSovereignReserve is Ownable, ReentrancyGuard, IERC777Sender, IERC777Recipient {
    IERC1820Registry private constant erc1820registry = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);

    AggregatorV3Interface public ethUsdPriceFeed;
    CryptoLandCitizenNFT412 public nftContract;
    TokenA public tokenA;
    
    // Constants
    uint256 private constant INITIAL_DAILY_RELEASE_AMOUNT = 10000 * 10**18;
    uint256 private constant DAILY_DECREASE_RATE = 9990; // 99.9%, applied daily
    uint256 private constant DECREASE_RATE_PRECISION = 10000;
    uint256 private constant MIN_PARTICIPATION_AMOUNT = 0.0001 ether;
    uint256 private constant SECONDS_PER_DAY = 86400;
    uint256 private constant PRECISION = 1e9;
    uint256 private constant MULTIPLIER_FACTOR = 20 * PRECISION;
    uint256 private constant MULTIPLIER_INCREMENT = 1e4;
    uint256 private constant TOTAL_RELEASE_100_YEARS = 241838856 * 10**18;
    uint256 private constant INITIAL_PARTICIPANTS = 1;
    uint256 private constant DECAY_RATE = 50;  // 5% per hour
    uint256 private constant DECAY_PRECISION = 1000;
    uint256 private constant FALLBACK_PRICE = 250000000000; // $2500 with 8 decimal places

    uint256 private lastGasUsed;

    // State variables
    uint256 public currentPeriodParticipants;
    uint256 public currentParticipants;
    uint256 public lastUpdateTime;
    uint256 public lastResetTime;
    uint256 public accumulatedValue;
    uint256 public totalParticipations;
    uint256 public contractStartTime;
    uint256 public lastUpdateTimestamp;
    uint256 public lastDailyReleaseAmount;
    uint256 public currentDailyReleaseAmount;
    uint256 public currentReleaseRate;
    uint256 public lastReleaseUpdateTimestamp;
    uint256 public decreaseRateAdjustment;
    uint256 public totalWeight;
    uint256 public lastResetTimestamp;
    uint256 public latestMiningEthAmount;
    uint256 public latestMiningTokenAReward;
    uint256 public latestMiningTimestamp;
    uint256 private fallbackEthUsdPrice;
    uint256 private lastEmittedPrice;
    uint256 private lastEmittedPriceTimestamp;
    uint256 public lastEstimationUpdateTimestamp;
    address public etherReceiver;

    uint256 public lastParticipantUpdateTime;
    uint256 public accumulatedHours;

    uint256 public lastDecayUpdateTime;
    uint256 public decayedParticipants;

    mapping(address => bool) public hasNFT;
    mapping(address => uint256) public lastParticipationTimestamp;
    

    // Events
    event NFTMinted(address indexed user, uint256 tokenId, uint256 valor);
    event ValorUpdated(address indexed user, uint256 newValor);
    event EthUsdPriceUpdated(uint256 newPrice, uint256 timestamp, string source);
    event FallbackPriceUpdated(uint256 newPrice);
    event ParticipantRewarded(address indexed participant, uint256 amount, uint256 weight);
    event EtherReceiverChanged(address indexed newReceiver);
    event EtherForwarded(address indexed to, uint256 amount);
    event DecreaseRateAdjustmentUpdated(uint256 newAdjustment);
    event DailyRateUpdated(uint256 newDailyReleaseAmount, uint256 newReleaseRate);
    event EthUsdPriceFeedUpdated(address indexed newPriceFeed);
    event DebugLog(string message, address indexed addr1, address indexed addr2, uint256 val1, uint256 val2);
    event ParticipantCountUpdated(uint256 count, uint256 timestamp);
    event ParticipantsReset(uint256 timestamp);
    event RewardMinted(address indexed participant, uint256 amount, bool success);
    event TokensReceived(address operator, address from, address to, uint256 amount, bytes userData, bytes operatorData);
    event TokensSent(address operator, address from, address to, uint256 amount, bytes userData, bytes operatorData);
    event TokenAAddressSet(address indexed newAddress);

    receive() external payable {
        if (msg.sender != owner()) {
            require(msg.value >= MIN_PARTICIPATION_AMOUNT, "Insufficient ETH sent");
            handleParticipation(msg.sender, msg.value);
        }
        forwardEther(msg.value);
    }

   
    }
} 


