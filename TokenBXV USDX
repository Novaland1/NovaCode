// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC777/ERC777.sol";
import "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol";
import "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol";
import "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

//The contract consists of two parts: the main contract and voting. The role of voting is based on the practice of liquid democracy. 
//The community jointly implements the expansion and contraction strategy of the stablecoin system and maintains reasonable market feedback. 
//Community members can obtain valuable perpetual assets through transactions and record them on the citizen NFTs.
//that try to democratize money, embed it into the micro level, and solve the impossible triangle problem of moneysystem.
//Feed the premium of the intermediary directly back to the actual value contribution through inflation.

interface ICryptoLandCitizenNFT412 {
    function updateValor(uint256 tokenId, int256 valorChange) external;
    function updateCredit(uint256 tokenId, int256 creditChange) external;
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
}

interface IVoting {
    function getCurrentVoteRate() external view returns (uint256);
    function handleVote(address voter, bool isUpVote, uint256 amount) external;
    function voteUpToken() external view returns (address);
    function voteDownToken() external view returns (address);
}

interface ITokenNovaEco is IERC777 {
    function mint(address to, uint256 amount) external;
    function burn(uint256 amount, bytes memory data) external;
    }

contract TokenBXV is ERC777, IERC777Sender, IERC777Recipient, Ownable  {
   
    IERC1820Registry private constant erc1820registry = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    AggregatorV3Interface public ethUsdPriceFeed;
    
    IVoting public votingContract;
    ITokenNovaEco public novaEcoToken;
      
    uint256 private constant INITIAL_FEE_RATE = 10; // Initial transfer fee: 0.1% (10/10000)
    uint256 private constant INITIAL_ACCUMULATION_RATE = 1000; // Initial 10% (1000/10000)
    uint256 private constant INITIAL_UPDATE_FEE = 0.001 ether;
    uint256 private constant INITIAL_TOKENS_TO_SEND_THRESHOLD = 1* 1e18; // 1000万 tokens
    
    uint256 private storedEthUsdPrice;
    uint256 public lastPriceUpdateTime;
    uint256 private constant PRICE_UPDATE_INTERVAL = 1 days;

    event VoteUpDestroyed(address from, uint256 amount);
    event VoteDownDestroyed(address from, uint256 amount);
    event VoteHandlingFailed(address voter, bool isUpVote, uint256 amount);

    event EthUsdPriceUpdated(uint256 price, uint256 timestamp, string source);

    event NFTContractUpdated(address indexed oldAddress, address indexed newAddress);

    uint256 private feeRate = INITIAL_FEE_RATE;
    uint256 private accumulationRate = INITIAL_ACCUMULATION_RATE;
    uint256 private updateFee = INITIAL_UPDATE_FEE;
    uint256 private tokensToSendThreshold = INITIAL_TOKENS_TO_SEND_THRESHOLD;

    

    // inflation function
    uint256 private _totalValorhere = 1; // initial set 1，avoid 0 status
    // Define constants
    uint256 public minMultiplier = 1e18 / 100;     // 默认1% (0.01 * 1e18)
    uint256 public maxMultiplier = 5 * 1e18 / 100; // 默认5% (0.5 * 1e18)
    
    struct FeeStructure {
        uint256 threshold;
        uint256 rate;
    }
    FeeStructure[] public feeStructures;

     address public feeRecipient;
     address public ethRecipient;

    ICryptoLandCitizenNFT412 public nftContract;
      
    mapping(address => uint256) public cumulativeCredit;
    mapping(address => uint256) public cumulativeValor;

    event NFTUpdated(address indexed user, uint256 tokenId, int256 valorChange, int256 creditChange);
    event FeeStructureUpdated();
    event TotalValorUpdated(uint256 newTotalValor);

    event VoteUpdated(uint256 upVotes,uint256 downVotes,bool isUpVote,address voter,uint256 amount);
    
    constructor(
    string memory name,
    string memory symbol,
    address[] memory defaultOperators,
    address _feeRecipient,
    address initialOwner,
    address _novaEcoToken,
    address _nftContract,
    address _ethRecipient,
    address _ethUsdPriceFeed,
    
    address _votingContract    // voting address
    ) ERC777(name, symbol, defaultOperators) Ownable(initialOwner) {
        nftContract = ICryptoLandCitizenNFT412(_nftContract);
        feeRecipient = _feeRecipient;
        ethRecipient = _ethRecipient;
        novaEcoToken = ITokenNovaEco(_novaEcoToken);
        ethUsdPriceFeed = AggregatorV3Interface(_ethUsdPriceFeed);
        storedEthUsdPrice = getEthUsdPrice();  // Use function calls instead of variables
        lastPriceUpdateTime = block.timestamp;
        votingContract = IVoting(_votingContract);

        // Initialize fee structures
        feeStructures.push(FeeStructure(100 * 1e18, 1));
        feeStructures.push(FeeStructure(1000 * 1e18, 3));
        feeStructures.push(FeeStructure(10000 * 1e18, 5));

        // Register interfaces
        erc1820registry.setInterfaceImplementer(address(this), keccak256("ERC777TokensSender"), address(this));
        erc1820registry.setInterfaceImplementer(address(this), keccak256("ERC777TokensRecipient"), address(this));

        emit EthUsdPriceUpdated(storedEthUsdPrice, block.timestamp, "initial");
    }

  
    receive() external payable {
    require(msg.value == updateFee, "Incorrect ETH amount");
    
    uint256 balance = nftContract.balanceOf(msg.sender);
    require(balance > 0, "No NFT owned");
    uint256 tokenId = nftContract.tokenOfOwnerByIndex(msg.sender, balance - 1);

    uint256 gasUsed = gasleft();
    int256 valorChange = int256(cumulativeValor[msg.sender] / 1e12); //update with 1e6
    int256 creditChange = int256(cumulativeCredit[msg.sender] / 1e12);//update with 1e6
    
    uint256 ethUsdPrice = getEthUsdPrice();
    uint256 gasValor = (gasUsed * tx.gasprice * ethUsdPrice )/ 1e18 ;//update with 1e6.reducing to 1e18
    nftContract.updateValor(tokenId, valorChange + int256(gasValor));
    nftContract.updateCredit(tokenId, creditChange);
    
    novaEcoToken.mint(msg.sender,  gasValor*1e12);

    cumulativeValor[msg.sender] = 0;
    cumulativeCredit[msg.sender] = 0;

    emit NFTUpdated(msg.sender, tokenId, valorChange + int256(gasValor), creditChange);

    (bool sent, ) = ethRecipient.call{value: msg.value}("");
    require(sent, "Failed to send ETH");
    }

    function setEthRecipient(address _newRecipient) external onlyOwner {
        require(_newRecipient != address(0), "Invalid address");
        ethRecipient = _newRecipient;
    }

      
}
